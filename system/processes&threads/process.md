# 进程

编写的代码知识存储在硬盘上的静态文件，通过编译生成二进制可执行文件，当可执行文件运行时，其会被装载进内存中，并交由 CPU 执行程序中的每一条指令，**运行中的程序，就被称为「进程」**。

当执行程序时，存在读取磁盘数据的情况，但是磁盘的读写速度非常慢（与 CPU 读写相比），在这个时候，如果 CPU 还在等待磁盘返回数据，那么 CPU 的利用率会非常低。

所以在进程要从磁盘读取数据时，CPU 不需要等待数据的返回，而是去执行其他的进程，而当磁盘返回数据时，向 CPU 发送**中断**，并继续执行这个进程。

![进程1与进程2切换](https://tvax3.sinaimg.cn/large/ad5fbf65ly1gj1sr60uv0j21740fudq3.jpg)

**多个程序、交替执行**的思想，比如单核的 CPU 在某一时间，只能运行一个进程，但是在运行时会产生**并行的错觉**，实际上是**并发**。

**进程的活动规律**： *「运行 - 暂停 -运行」*

**并发与并行的区别**

![并发与并行](https://tva3.sinaimg.cn/large/ad5fbf65ly1gj1t7pu807j211c0ug11a.jpg)

## 状态

一般来说，一个进程并不是自始至终连续不断运行的，它与并发执行中的其他进程是相互制约的。

所以一个进程在活动中至少具有三个状态：**运行状态（Running）、就绪状态（Ready）、阻塞状态（Blocked）**

![进程的三种基本状态](https://tvax3.sinaimg.cn/large/ad5fbf65ly1gj1tdcpmrgj219y0jak13.jpg)

此外，进程还有另外两只基本状态：**创建状态（New）、结束状态（Exit）**

![进程五种状态变迁](https://tvax2.sinaimg.cn/large/ad5fbf65ly1gj1tfn6eomj21jy0igk38.jpg)

另外还有一种**挂起状态**，表示进程没有占有物流内存空间，由于虚拟内存管理原因，进程所使用的空间可能没有映射到物理内存，而是在磁盘上，这时进程就会进入挂起状态，另外调用 *Sleep* 也会被挂起。

![虚拟内存管理-换入换出](https://tva4.sinaimg.cn/large/ad5fbf65ly1gj1tl4snqgj21o010kgza.jpg)

挂起状态可以分两种：

- **阻塞挂起状态**：进程在磁盘并等待某个事件的出现
- **就绪挂起状态**：进程在磁盘，但只要进入内存，立即就可执行

加上挂起状态的两种，就有了七种状态变迁：

![七种状态变迁](https://tva2.sinaimg.cn/large/ad5fbf65ly1gj1tozrs1sj21o01164j5.jpg)

## 控制结构

使用**进程控制块（process control block, PCB）**数据结构来描述进程。**PCB 是进程存在的唯一标识**，如果进程消失，则 PCB 也随之消失。

### PCB 具体包含信息

**进程描述信息：**

- **进程标识符**：标识各个进程，每个进程都有一个唯一的标识
- **用户标识符**：进程归属用户，用户标识符主要为共享和保护服务

**进程控制和管理信息：**

- **进程当前状态**，如 new、ready、running、waiting、blocked 等
- **进程优先级**：进程抢占 CPU 时的优先级

**资源分配清单：**

- 内存地址空间、虚拟地址空间信息，所打开文件的列表和所使用的 I/O 设备信息

**CPU 相关信息：**

- CPU 中各个寄存器的值，当进程被切换时，CPU 的状态信息会保存在相应 PCB 中，以便进程重新执行时，能从断点继续执行

#### PCB 的组织方式

通常使用**链表**，把具有**相同状态的进程链在一起，组成各种队列**。

![就绪队列和阻塞队列](https://tva2.sinaimg.cn/large/ad5fbf65ly1gj1ubbuobuj21mg0vstfl.jpg)

除了链接的组织方式，还有索引方式：将同一个状态的进程组织在一个索引表中，索引表项指向相应的 PCB，不同状态对应不同索引表。

一般还会选择链表，因为可能面临进程创建、销毁等调度导致进程状态发生变化，所以链表能够更加灵活的插入和删除。

## 控制

进程的**创建、终止、阻塞、唤醒**过程，也就是进程的控制。

### 创建进程

操作系统允许一个进程创建另一个进程，且允许子进程继承父进程所拥有的资源，当子进程终止时，会向父进程归还其继承的资源。同时，终止父进程也会终止其所有子进程。

创建过程：

1. 分配唯一进程标识号，申请空白 PCB。（PCB 是有限的，若申请失败则创建失败）
2. 为进程分配资源（若资源不足，则进入等待状态，等待资源）
3. 初始化 PCB
4. 如果进程的调度队列能够接纳新进程，那么将进程插入到就绪队列，等待被调度运行

### 终止进程

有三种方式可以终止进程：**正常结束**、**异常结束**、**外界干预（信号 `kill` 掉）**。

终止过程：

1. 查找需要终止进程的 PCB
2. 如果处于执行状态，则立即终止该进程的执行，将 CPU 资源分配给其他进程
3. 如果有子进程，则终止其所有子进程
4. 将该进程所拥有的全部资源都归还给*父进程*或*操作系统*
5. 将 PCB 中所在队列中删除

### 阻塞进程

当进程需要等待某一事件完成时，它可以使用阻塞语句把自己阻塞等待。而一旦被阻塞等待，它只能由另一个进程唤醒。

阻塞过程：

1. 查找将要被阻塞进程的 PCB
2. 如果该进程为运行状态，则保护现场，将其状态转为阻塞状态，停止运行
3. 将该 PCB 插入阻塞队列

### 唤醒进程

阻塞状态的进程由于必须等待某一事件的完成，所以决不能自己叫醒自己，需要别的进程发消息给他才行。

唤醒过程：

1. 在该事件的阻塞队列中找到相应进程的 PCB
2. 将其从阻塞队列中移出，并置其状态为就绪状态
3. 将该 PCB 插入到就绪队列，等待调度程序调度

## 上下文切换

各个进程之间是共享 CPU 资源的，**一个进程切换到另一个进程运行，称之为进程的上下文切换**。

### 进程的上下文切换

进程是由内核管理和调度的，所以进程的切换只能发生在**内核态**。

**进程的上下文切换不仅包含了虚拟内存、栈、全局变量等用户空间的资源，还包括了内核堆栈、寄存器等内核空间资源。**

通常交换的信息会保存在进程的 PCB，当运行另一个进程时，会从其 PCB 取出上下文，使得进程继续执行。

![进程的上下文切换](https://tva1.sinaimg.cn/large/ad5fbf65ly1gj1vq0aeulj21cc0am79o.jpg)

进程的上下文切换是有开销的，所以我们希望它的开销越小越好。

### 发生进程切换的场景

- 为了保证进程公平调度，CPU 时间被划分成时间片，将时间片轮流分配给各个进程。当进程的时间片耗尽，就会发生进程上下文切换
- 进程在系统资源不足时（如内存资源），需要等待资源，这是发生进程上下文切换，调度其他进程运行
- 进程通过 `Sleep` 主动挂起，进程重新调度
- 发生硬件中断时，CPU 上的进程会被中断挂起，转而执行内核的中断程序服务
